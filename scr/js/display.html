<script>
    // Global variables
    let currentQueueData = null;
    let soundMap = {};
    let audioContext;
    let audioQueue = [];
    let isPlayingAudio = false;
    let lastRecallSignalTimestamp = null;
    let refreshInterval;
    let currentVideoId = null; // Track the current video ID to avoid reloading

    // Slideshow specific variables
    let slideshowImageObjects = []; // Changed name for clarity
    let currentSlideshowIndex = 0;
    let slideshowIntervalId = null;
    let slideshowInterval = 7000; // Default: 7 seconds per image
    let slideshowTransition = 'fade'; // Default transition effect

    // --- Sound Generation Settings ---
    let soundGenerationMethod = 'url'; // Default, updated from server settings
    // Map sound type keys from pattern to Thai phrases for TTS methods
    const ttsPhrases = {
        'start_call': 'เชิญหมายเลขคิว',
        'end_call': 'ค่ะ',
        'counter_prefix': 'ที่ช่องบริการหมายเลข',
        // Add other sound types here if they have text equivalents for TTS

    };
    
    // DOM Element Variables - Declare all globals here
    let currentQueueEl;
    let currentServiceEl;
    let completedQueueHistoryEl;
    let waitingQueueListEl;
    let skippedQueueListEl;
    let skippedQueuesSectionEl;
    let currentTimeEl;
    let organizationNameDisplayEl;
    let youtubePlayerEl;
    let slideshowImageEl;
    let mediaPlaceholderEl;
    let callingIndicatorEl;
    let interactionOverlay;
    let startDisplayButton;
    let ttsAvailableVoices = []; // Store available voices for TTS

    // Function to initialize DOM elements
    function initDOMElements() {
        console.log("Initializing DOM elements");
        currentQueueEl = document.getElementById('currentQueue');
        currentServiceEl = document.getElementById('currentService'); // This is for the *current* calling queue
        completedQueueHistoryEl = document.getElementById('completedQueueHistory');
        // queueHistoryEl = document.getElementById('queueHistory'); // This element ID doesn't exist / not used.
        skippedQueueListEl = document.getElementById('skippedQueueList');
        skippedQueuesSectionEl = document.getElementById('skippedQueuesSection');
        currentTimeEl = document.getElementById('currentTime');
        organizationNameDisplayEl = document.getElementById('organizationNameDisplay');
        youtubePlayerEl = document.getElementById('youtubePlayer');
        slideshowImageEl = document.getElementById('slideshowImage');
        mediaPlaceholderEl = document.getElementById('mediaPlaceholder');
        waitingQueueListEl = document.getElementById('waitingQueueList'); // Added
        callingIndicatorEl = document.getElementById('callingIndicator'); // Added
        interactionOverlay = document.getElementById('interactionOverlay');
        startDisplayButton = document.getElementById('startDisplayButton');

        // Initialize TTS voices
        if ('speechSynthesis' in window) {
            loadTTSVoices(); // Initial load
            // Listen for changes in available voices
            window.speechSynthesis.onvoiceschanged = loadTTSVoices;
        }
    }

    function initAudioContext() {
        try {
            if (!audioContext && (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined')) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log("AudioContext created with state:", audioContext.state);
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume()
                    .then(() => console.log("AudioContext resumed successfully, state:", audioContext.state))
                    .catch(e => console.error("Error resuming audio context:", e));
            }
        } catch (e) {
            console.error("Error initializing AudioContext:", e);
        }
    }

    function loadTTSVoices() {
        ttsAvailableVoices = window.speechSynthesis.getVoices();
        console.log("TTS voices loaded/updated. Count:", ttsAvailableVoices.length);
        // ttsAvailableVoices.forEach(voice => console.log(`Voice: ${voice.name}, Lang: ${voice.lang}, Default: ${voice.default}`));
    }

    function setupEventListeners() {
        if (startDisplayButton && interactionOverlay) {
            console.log("Setting up start button click listener");
            startDisplayButton.addEventListener('click', function() {
                console.log("Start button clicked");
                startDisplay();
            });
            
            // Add test sound button listener
            const testSoundButton = document.getElementById('testSoundButton');
            if (testSoundButton) {
                testSoundButton.addEventListener('click', function() {
                    console.log("Test sound button clicked");
                    initAudioContext();
                    
                    // Play a test sound if we have data
                    if (currentQueueData && currentQueueData.calling) {
                        playQueueSound(
                            currentQueueData.calling.number,
                            currentQueueData.calling.counterId,
                            currentQueueData.calling.counterNameSoundId,
                            currentQueueData.announcementPattern,
                            currentQueueData.counterAnnouncementType
                        );
                    } else {
                        // Play a default test sound if no queue data
                        const testAudio = new Audio('https://weerasak3s.github.io/media/1-1.mp3');
                        testAudio.play().catch(function(error) {
                            console.error("Error playing test sound:", error);
                            alert("ไม่สามารถเล่นเสียงทดสอบได้ กรุณาคลิกที่ปุ่มเริ่มแสดงผลก่อน");
                        });
                    }
                });
            }
        } else {
            console.warn("Interaction overlay or start button not found. Audio might not play without user interaction.");
            // Start anyway since the button isn't available
            startDisplay();
        }
    }

    function startDisplay() {
        console.log("Starting display");
        initAudioContext();
        
        if (interactionOverlay) {
            interactionOverlay.style.display = 'none';
        }
        
        fetchInitialData(); 
        
        if (refreshInterval) {
            clearInterval(refreshInterval);
        }
        
        refreshInterval = setInterval(fetchAdminDashboardData, 5000);
    }

    function fetchInitialData() {
        google.script.run.withSuccessHandler(function(sounds) {
            soundMap = sounds;
            console.log("Sound map loaded:", soundMap);
        }).withFailureHandler(function(error) {
            console.error("Error loading sound map:", error);
        }).getSoundUrls();

        fetchAdminDashboardData(); 
    }

    function fetchAdminDashboardData() {
        google.script.run
            .withSuccessHandler(updateDisplay)
            .withFailureHandler(function(error) {
                console.error('Error fetching admin dashboard data:', error);
            })
            .getAdminDashboardData();
    }

    function updateDisplay(data) {
        console.log("Received data for display:", data);
        if (data.error) {
            console.error("Error from server:", data.error);
            if (currentQueueEl) currentQueueEl.textContent = "Error";
            if (currentServiceEl) currentServiceEl.textContent = data.error;
            return;
        }

        // Store previous calling queue to detect changes
        const previousCallingQueueNumber = currentQueueData && currentQueueData.calling ? currentQueueData.calling.number : null;

        // Update sound generation method from server data
        if (data.SoundGenerationMethod) {
            soundGenerationMethod = data.SoundGenerationMethod;
            console.log("Sound generation method set to:", soundGenerationMethod);
        }
        currentQueueData = data; 

        // Update display settings
        console.log("Updating display settings from server data");
        
        // Update slideshow interval if provided
        if (data.SlideshowInterval) {
            const newInterval = parseInt(data.SlideshowInterval) * 1000; // Convert seconds to milliseconds
            if (newInterval !== slideshowInterval) {
                console.log(`Updating slideshow interval from ${slideshowInterval}ms to ${newInterval}ms`);
                slideshowInterval = newInterval;
                
                // Restart slideshow with new interval if it's currently running
                if (slideshowIntervalId) {
                    console.log("Restarting slideshow with new interval");
                    clearInterval(slideshowIntervalId);
                    slideshowIntervalId = null;
                    if (displayType === 'slideshow' && slideshowImageObjects.length > 0) {
                        startImageSlideshow();
                    }
                }
            }
        }
        
        // Update slideshow transition if provided
        if (data.SlideshowTransition) {
            if (data.SlideshowTransition !== slideshowTransition) {
                console.log(`Updating slideshow transition from ${slideshowTransition} to ${data.SlideshowTransition}`);
                slideshowTransition = data.SlideshowTransition;
            }
        }

        if (organizationNameDisplayEl && data.organizationName) {
            organizationNameDisplayEl.textContent = data.organizationName;
        }

        const currentQueueCardEl = document.getElementById('currentQueueCard');

        if (data.calling) {
            // Format queue number as 3-digit with leading zeros
            if (currentQueueEl) {
                const queueNumber = data.calling.number || '-';
                currentQueueEl.textContent = (queueNumber !== '-') ? String(queueNumber).padStart(3, '0') : queueNumber;
            }
            if (currentServiceEl) currentServiceEl.textContent = data.calling.serviceName || 'รอช่องบริการ';
            
            // currentQueueCardEl should always be visible.
            // Re-trigger slide-in animation if the calling queue number has changed.
            if (currentQueueCardEl && previousCallingQueueNumber !== data.calling.number) {
                currentQueueCardEl.classList.remove('slide-in');
                void currentQueueCardEl.offsetWidth; // Trigger reflow to restart animation
                currentQueueCardEl.classList.add('slide-in');
            }

            if (callingIndicatorEl) {
                callingIndicatorEl.classList.remove('hidden'); // Show "กำลังเรียกคิว" and bell
            }
            
            // Check for recall signal
            if (data.recallSignal && data.recallSignal.timestamp !== lastRecallSignalTimestamp) {
                console.log("New recall signal detected:", data.recallSignal);
                // Force audio context initialization before playing sound
                initAudioContext();
                playQueueSound(data.calling.number, data.calling.counterId, data.calling.counterNameSoundId, data.announcementPattern, data.counterAnnouncementType);
                lastRecallSignalTimestamp = data.recallSignal.timestamp;
                google.script.run.withSuccessHandler(function() {
                    console.log("Recall signal cleared from server.");
                }).withFailureHandler(function(err) {
                    console.error("Error clearing recall signal:", err);
                }).clearRecallSignal();
            }
            // Also play sound when a new queue is called (not just on recall)
            else if (previousCallingQueueNumber !== data.calling.number) {
                console.log("New queue detected, playing announcement");
                // Force audio context initialization before playing sound
                initAudioContext();
                playQueueSound(data.calling.number, data.calling.counterId, data.calling.counterNameSoundId, data.announcementPattern, data.counterAnnouncementType);
            }
        } else { // No queue is calling
            if (currentQueueEl) currentQueueEl.textContent = '-';
            if (currentServiceEl) currentServiceEl.textContent = 'ไม่มีคิวเรียก';
            
            // currentQueueCardEl remains visible.

            if (callingIndicatorEl) {
                callingIndicatorEl.classList.add('hidden'); // Hide "กำลังเรียกคิว" and bell
            }
        }

        // Update Completed Queue History (Right Column)
        if (completedQueueHistoryEl) {
            completedQueueHistoryEl.innerHTML = '';
            if (data.completed && data.completed.length > 0) {
                data.completed.forEach(function(q) {
                    const item = document.createElement('div');
                    item.className = 'bg-green-100 p-4 rounded-lg shadow flex justify-between items-center';
                    // Format queue number as 3-digit with leading zeros
                    const formattedQueueNumber = String(q.number).padStart(3, '0');
                    let timeDisplay = '-';
                    if (q.timestamp) {
                        const timestampDate = new Date(q.timestamp);
                        if (isNaN(timestampDate.getTime())) {
                            console.warn("Invalid timestamp for completed queue:", q.number, q.timestamp);
                        } else {
                            timeDisplay = timestampDate.toLocaleTimeString('th-TH', {
                                hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
                            });
                        }
                    }
                    item.innerHTML = '<div class="flex items-center gap-3"><span class="text-2xl font-bold text-green-700">' + formattedQueueNumber + '</span><span class="text-sm text-gray-600">' + (q.serviceName || 'N/A') + '</span></div><span class="text-sm text-gray-500">' + timeDisplay + '</span>';
                    completedQueueHistoryEl.appendChild(item);
                });
            } else {
                completedQueueHistoryEl.innerHTML = '<p class="text-gray-500 text-center">ยังไม่มีคิวที่สำเร็จ</p>';
            }
        }

        // Update Waiting Queue List (Left Column)
        if (waitingQueueListEl) {
            waitingQueueListEl.innerHTML = '';
            if (data.nextWaitingQueues && data.nextWaitingQueues.length > 0) {
                 data.nextWaitingQueues.forEach(function(q) {
                    const item = document.createElement('div');
                    // Apply light purple styling
                    item.className = 'bg-purple-100 p-4 rounded-lg shadow flex justify-between items-center';
                    // Format queue number as 3-digit with leading zeros
                    const formattedQueueNumber = String(q.number).padStart(3, '0');
                    // Only display the formatted queue number
                    item.innerHTML = '<div class="flex items-center gap-3"><span class="text-2xl font-bold text-purple-700">' + formattedQueueNumber + '</span></div>';
                    waitingQueueListEl.appendChild(item);
                });
            } else {
                waitingQueueListEl.innerHTML = '<p class="text-gray-500 text-center">ยังไม่มีคิวรอเรียก</p>';
            }
        }

        if (skippedQueueListEl && skippedQueuesSectionEl) {
            if (data.skipped && data.skipped.length > 0) {
                // Only show queue numbers as 3-digit with leading zeros, separated by commas
                const queueNumbers = data.skipped.map(q => String(q.number).padStart(3, '0')).join(', ');
                skippedQueueListEl.textContent = queueNumbers;
                skippedQueuesSectionEl.classList.remove('hidden');
            } else {
                skippedQueuesSectionEl.classList.add('hidden');
            }
        }
        
        updateMediaContent(data.mediaUrl, data.slideshowImages);

        if (currentTimeEl) {
            const now = new Date();
            // Format time with clear hour:minute:second format
            currentTimeEl.textContent = now.toLocaleTimeString('th-TH', { 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit',
                hour12: false // Use 24-hour format
            });
        }
    }

    function updateMediaContent(mediaUrl, newSlideshowImageObjects) {
        const hasYoutubeUrl = mediaUrl && mediaUrl.trim() !== '';
        const hasSlideshow = newSlideshowImageObjects && newSlideshowImageObjects.length > 0;
        
        // Get display type from server data, default to slideshow if there are slideshow images available
        const displayType = currentQueueData.DisplayType || (hasSlideshow ? 'slideshow' : 'video');
        
        console.log("Media content update - Display type:", displayType, 
                    "Has YouTube:", hasYoutubeUrl, 
                    "Has slideshow images:", hasSlideshow, 
                    "Slideshow image count:", newSlideshowImageObjects ? newSlideshowImageObjects.length : 0,
                    "Slideshow interval:", slideshowInterval);

        // Always stop any existing slideshow before deciding what to display
        if (slideshowIntervalId) {
            console.log("Stopping existing slideshow");
            clearInterval(slideshowIntervalId);
            slideshowIntervalId = null;
        }
        
        // Check if slideshow images have changed
        let slideshowImagesChanged = false;
        if (hasSlideshow && slideshowImageObjects.length === newSlideshowImageObjects.length) {
            // Check if any image URLs have changed
            for (let i = 0; i < newSlideshowImageObjects.length; i++) {
                if (newSlideshowImageObjects[i].url !== slideshowImageObjects[i].url) {
                    console.log(`Image at index ${i} changed from ${slideshowImageObjects[i].url} to ${newSlideshowImageObjects[i].url}`);
                    slideshowImagesChanged = true;
                    break;
                }
            }
        } else {
            console.log(`Slideshow image count changed: old=${slideshowImageObjects.length}, new=${newSlideshowImageObjects ? newSlideshowImageObjects.length : 0}`);
            slideshowImagesChanged = true;
        }
        
        if (slideshowImagesChanged && hasSlideshow) {
            console.log("Slideshow images have changed, updating...");
        }

        // Determine what to display based on display type and available content
        console.log(`Applying display type: ${displayType}`);
        
        if (displayType === 'video') {
            // Video mode selected
            if (hasYoutubeUrl) {
                // Display YouTube video
                if (youtubePlayerEl) {
                    const videoId = extractYouTubeVideoId(mediaUrl);
                    if (videoId) {
                        // Only update the iframe src if the video ID has changed or if it's not already playing
                        if (videoId !== currentVideoId || youtubePlayerEl.style.display === 'none') {
                            console.log("Loading new video or displaying previously hidden video:", videoId);
                            // Keep mute=1 to prevent YouTube audio from interfering with queue announcements
                            youtubePlayerEl.src = 'https://www.youtube.com/embed/' + videoId + '?autoplay=1&mute=1&controls=0&showinfo=0&rel=0&iv_load_policy=3&modestbranding=1&loop=1&playlist=' + videoId;
                            currentVideoId = videoId;
                        } else {
                            console.log("Video already playing, not reloading:", videoId);
                        }
                        // Ensure the video fills the available space and is centered
                        youtubePlayerEl.style.display = 'block';
                        youtubePlayerEl.style.width = '100%';
                        youtubePlayerEl.style.height = '100%';
                        youtubePlayerEl.style.margin = '0';
                        youtubePlayerEl.style.position = 'relative';
                        youtubePlayerEl.style.top = '50%';
                        youtubePlayerEl.style.transform = 'translateY(-50%)';
                    } else {
                        youtubePlayerEl.style.display = 'none';
                        currentVideoId = null;
                        console.log("No valid YouTube video ID found in URL:", mediaUrl);
                    }
                }
                if (slideshowImageEl) slideshowImageEl.style.display = 'none';
                if (mediaPlaceholderEl) mediaPlaceholderEl.style.display = 'none';
            } else {
                // No YouTube URL available, show placeholder or fallback to slideshow
                console.log("Video mode selected but no YouTube URL available");
                if (hasSlideshow) {
                    console.log("Falling back to slideshow mode");
                    slideshowImageObjects = newSlideshowImageObjects;
                    currentSlideshowIndex = 0;
                    startImageSlideshow();
                    if (youtubePlayerEl) youtubePlayerEl.style.display = 'none';
                    if (mediaPlaceholderEl) mediaPlaceholderEl.style.display = 'none';
                } else {
                    // No slideshow available either, show placeholder
                    if (youtubePlayerEl) youtubePlayerEl.style.display = 'none';
                    if (slideshowImageEl) slideshowImageEl.style.display = 'none';
                    if (mediaPlaceholderEl) mediaPlaceholderEl.style.display = 'block';
                }
            }
        } else if (displayType === 'slideshow') {
            // Slideshow mode selected
            if (hasSlideshow) {
                // Display slideshow from SlideshowImages sheet
                console.log("Starting slideshow with", newSlideshowImageObjects.length, "images");
                slideshowImageObjects = newSlideshowImageObjects;
                currentSlideshowIndex = 0;
                startImageSlideshow();
                if (youtubePlayerEl) {
                    youtubePlayerEl.style.display = 'none';
                    // Don't reset currentVideoId here, so we can resume the video if we switch back
                }
                if (mediaPlaceholderEl) mediaPlaceholderEl.style.display = 'none';
            } else {
                // No slideshow images available, fallback to video or placeholder
                console.log("Slideshow mode selected but no images available");
                if (hasYoutubeUrl) {
                    console.log("Falling back to video mode");
                    if (youtubePlayerEl) {
                        const videoId = extractYouTubeVideoId(mediaUrl);
                        if (videoId) {
                            youtubePlayerEl.src = 'https://www.youtube.com/embed/' + videoId + '?autoplay=1&mute=1&controls=0&showinfo=0&rel=0&iv_load_policy=3&modestbranding=1&loop=1&playlist=' + videoId;
                            currentVideoId = videoId;
                            youtubePlayerEl.style.display = 'block';
                            youtubePlayerEl.style.width = '100%';
                            youtubePlayerEl.style.height = '100%';
                            youtubePlayerEl.style.margin = '0';
                            youtubePlayerEl.style.position = 'relative';
                            youtubePlayerEl.style.top = '50%';
                            youtubePlayerEl.style.transform = 'translateY(-50%)';
                        }
                    }
                    if (slideshowImageEl) slideshowImageEl.style.display = 'none';
                    if (mediaPlaceholderEl) mediaPlaceholderEl.style.display = 'none';
                } else {
                    // No content available for either type
                    if (youtubePlayerEl) youtubePlayerEl.style.display = 'none';
                    if (slideshowImageEl) slideshowImageEl.style.display = 'none';
                    if (mediaPlaceholderEl) mediaPlaceholderEl.style.display = 'block';
                }
            }
        } else {
            // Unknown display type, show placeholder
            console.log("Unknown display type:", displayType);
            if (youtubePlayerEl) {
                youtubePlayerEl.style.display = 'none';
                currentVideoId = null;
            }
            if (slideshowImageEl) slideshowImageEl.style.display = 'none';
            if (mediaPlaceholderEl) mediaPlaceholderEl.style.display = 'block';
        }
    }

    function startImageSlideshow() {
        if (!slideshowImageEl || slideshowImageObjects.length === 0) {
            if(slideshowImageEl) slideshowImageEl.style.display = 'none';
            console.log("Cannot start slideshow: No image element or no images available");
            return;
        }
        
        console.log(`Starting slideshow with ${slideshowImageObjects.length} images`);
        slideshowImageEl.style.display = 'block';
        
        // Apply transition effect based on settings
        if (slideshowTransition === 'fade') {
            slideshowImageEl.style.transition = 'opacity 0.5s ease-in-out';
        } else if (slideshowTransition === 'slide') {
            slideshowImageEl.style.transition = 'transform 0.5s ease-in-out';
        } else {
            slideshowImageEl.style.transition = 'none';
        }
        
        // Ensure the image fills the available space and is centered
        slideshowImageEl.style.width = '100%';
        slideshowImageEl.style.height = '100%';
        slideshowImageEl.style.objectFit = 'contain';
        slideshowImageEl.style.objectPosition = 'center center'; // Ensure centering both horizontally and vertically
        slideshowImageEl.style.margin = '0';

        function showNextImage() {
            if (slideshowImageObjects.length === 0) return; 
            
            // Apply transition effect
            if (slideshowTransition === 'fade') {
                slideshowImageEl.style.opacity = '0';
                setTimeout(() => {
                    updateSlideshowImage();
                    slideshowImageEl.style.opacity = '1';
                }, 500);
            } else if (slideshowTransition === 'slide') {
                slideshowImageEl.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    updateSlideshowImage();
                    slideshowImageEl.style.transform = 'translateX(0)';
                }, 500);
            } else {
                updateSlideshowImage();
            }
        }
        
        function updateSlideshowImage() {
            const imageObject = slideshowImageObjects[currentSlideshowIndex];
            
            // Robustness check for the URL
            if (imageObject && typeof imageObject.url === 'string' && (imageObject.url.startsWith('http://') || imageObject.url.startsWith('https://'))) {
                slideshowImageEl.src = imageObject.url;
                slideshowImageEl.alt = imageObject.title || 'Slideshow Image';
                console.log(`Showing image ${currentSlideshowIndex + 1}/${slideshowImageObjects.length}: ${imageObject.title || 'Untitled'}`);
            } else {
                console.warn('Skipping invalid slideshow URL:', imageObject ? imageObject.url : 'undefined/invalid object', 'at index:', currentSlideshowIndex);
            }

            currentSlideshowIndex = (currentSlideshowIndex + 1) % slideshowImageObjects.length;
        }

        // Initialize first image without transition
        updateSlideshowImage();
        
        // Set interval using the configured interval time
        if (slideshowIntervalId) {
            clearInterval(slideshowIntervalId);
        }
        slideshowIntervalId = setInterval(showNextImage, slideshowInterval);
        console.log(`Slideshow interval set to ${slideshowInterval}ms (${slideshowInterval/1000} seconds)`);
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        let videoId = null;
        const regExpWatch = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
        const matchWatch = url.match(regExpWatch);
        if (matchWatch && matchWatch[2].length === 11) {
            videoId = matchWatch[2];
        } else {
            const regExpShort = /youtu\.be\/([^#\&\?]{11})/;
            const matchShort = url.match(regExpShort);
            if (matchShort && matchShort[1].length === 11) {
                videoId = matchShort[1];
            }
        }
        return videoId;
    }

    function playQueueSound(queueNumber, counterIdentifier, counterNameSoundId, announcementPattern, counterAnnouncementType) {
        console.log("playQueueSound called with: Q=" + queueNumber + ", CID=" + counterIdentifier + ", NameSoundID=" + counterNameSoundId + ", Pattern='" + announcementPattern + "', Type='" + counterAnnouncementType + "'");
        
        // Always try to initialize audio context first
        initAudioContext();
        
        // Add a small delay to ensure audio context has time to initialize
        setTimeout(function() {
            if (!audioContext || audioContext.state === 'suspended') {
                console.warn("AudioContext not active. User interaction might be needed to enable sound.");
                
                // Try to resume the audio context with user interaction simulation
                document.body.addEventListener('click', function resumeAudioOnce() {
                    initAudioContext();
                    document.body.removeEventListener('click', resumeAudioOnce);
                    
                    // Queue the sound play request to try again after user interaction
                    // For URL method, we queue the URLs. For TTS, we'd queue the text generation.
                    // Simplified: just re-call processQueueSound after interaction.
                    // This might lead to double processing if not handled carefully.
                    // A better approach for suspended context is to show a "click to enable sound" message.
                    // For now, let's assume the initial interaction overlay handles this.
                    // If it's still suspended here, it's a persistent issue.
                    // We will proceed, and if it fails, console logs will show.
                    // audioQueue.push({ type: 'queueCall', data: { queueNumber, counterIdentifier, counterNameSoundId, announcementPattern, counterAnnouncementType } });
                    processQueueSoundInternal(); // Retry internal processing
                    console.log("Added queue call to audio queue for after user interaction");
                }, { once: true });
                
                // Show a message to encourage user interaction
                const audioMessage = document.createElement('div');
                audioMessage.style.position = 'fixed';
                audioMessage.style.top = '50%';
                audioMessage.style.left = '50%';
                audioMessage.style.transform = 'translate(-50%, -50%)';
                audioMessage.style.padding = '20px';
                audioMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                audioMessage.style.color = 'white';
                audioMessage.style.borderRadius = '10px';
                audioMessage.style.zIndex = '10000';
                audioMessage.style.textAlign = 'center';
                audioMessage.innerHTML = 'คลิกที่ใดก็ได้เพื่อเปิดใช้งานเสียง';
                
                document.body.appendChild(audioMessage);
                
                setTimeout(function() {
                    if (document.body.contains(audioMessage)) {
                        document.body.removeChild(audioMessage);
                    }
                }, 5000);
                
                return;
            }
            
            processQueueSoundInternal();
        }, 100);
        
        function processQueueSoundInternal() {
            if (soundGenerationMethod === 'url' && (Object.keys(soundMap).length === 0 || !soundMap.digits || !soundMap.types || !soundMap.rawById)) {
                console.warn("URL method: Sound map not fully loaded or is empty. Cannot play announcement.");
                return;
            }

            const patternParts = announcementPattern.split(',');
            let fullTextForTTS = "";
            const audioSequenceForURL = [];

            patternParts.forEach(part => {
                part = part.trim();
                if (soundGenerationMethod === 'url') {
                    if (part === "{QUEUE_NUMBER}") {
                        const queueDigits = String(queueNumber).padStart(3, '0');
                        for (let i = 0; i < queueDigits.length; i++) {
                            const digit = queueDigits[i];
                            if (soundMap.digits && soundMap.digits[digit]) {
                                audioSequenceForURL.push(soundMap.digits[digit]);
                            } else { console.warn("URL: Sound for queue digit '" + digit + "' not found."); }
                        }
                    } else if (part === "{COUNTER_NUMBER}") {
                        if (counterAnnouncementType === 'name_sound' && counterNameSoundId && soundMap.rawById[counterNameSoundId]) {
                            audioSequenceForURL.push(soundMap.rawById[counterNameSoundId]);
                        } else if (counterIdentifier) {
                            const counterDigits = String(counterIdentifier);
                            for (let i = 0; i < counterDigits.length; i++) {
                                const digit = counterDigits[i];
                                if (soundMap.digits && soundMap.digits[digit]) {
                                    audioSequenceForURL.push(soundMap.digits[digit]);
                                } else { console.warn("URL: Sound for counter digit '" + digit + "' not found."); }
                            }
                        } else {
                            console.warn("URL: Counter ID not available for {COUNTER_NUMBER} and not using name_sound.");
                        }
                    } else if (part.startsWith("SOUND_TYPE_")) {
                        const typeKey = part.replace("SOUND_TYPE_", "").toLowerCase();
                        if (soundMap.types && soundMap.types[typeKey]) {
                            audioSequenceForURL.push(soundMap.types[typeKey]);
                        } else { console.warn("URL: Sound for type '" + typeKey + "' (from " + part + ") not found."); }
                    } else if (soundMap.rawById[part]) {
                        audioSequenceForURL.push(soundMap.rawById[part]);
                    } else {
                        console.warn("URL: Unknown part in pattern or sound ID not found: '" + part + "'");
                    }
                } else { // For 'web_speech' or 'google_cloud_tts'
                    let textPart = "";
                    if (part === "{QUEUE_NUMBER}") {
                        textPart = String(queueNumber); // TTS engines will convert "123" to "หนึ่งร้อยยี่สิบสาม"
                    } else if (part === "{COUNTER_NUMBER}") {
                        // Use serviceName if 'name_sound' and available, otherwise use counterIdentifier
                        if (counterAnnouncementType === 'name_sound' && 
                            currentQueueData && currentQueueData.calling && currentQueueData.calling.serviceName) {
                            textPart = currentQueueData.calling.serviceName;
                        } else if (counterIdentifier) {
                            textPart = String(counterIdentifier);
                        } else {
                             console.warn("TTS: Counter identifier not available for {COUNTER_NUMBER}.");
                        }
                    } else if (part.startsWith("SOUND_TYPE_")) {
                        const typeKey = part.replace("SOUND_TYPE_", "").toLowerCase();
                        textPart = ttsPhrases[typeKey] || ""; // Get Thai phrase or empty string
                        if (!textPart) console.warn("TTS: No Thai phrase defined for SOUND_TYPE_ '" + typeKey + "'");
                    } else {
                        // This case handles parts of the pattern that are not placeholders or known SOUND_TYPE_
                        // It assumes such parts are literal text to be spoken.
                        // Example: Pattern "คิว,{QUEUE_NUMBER},เชิญที่,{COUNTER_NUMBER},ครับ"
                        // Here, "คิว", "เชิญที่", "ครับ" would be `part` and become `textPart`.
                        // However, the current `soundMap.rawById[part]` check is for URL method.
                        // For TTS, if a pattern contains a sound ID like '11', it's ambiguous.
                        // Best practice for TTS patterns: use SOUND_TYPE_ for semantic parts, or literal Thai text.
                        // For now, we'll assume non-placeholder, non-SOUND_TYPE_ parts are not standard for TTS.
                        console.warn("TTS: Unknown or non-standard part in pattern: '" + part + "'. It will be ignored for TTS string construction unless it's a literal Thai phrase intended for the pattern.");
                    }
                    if (textPart) {
                        fullTextForTTS += (fullTextForTTS ? " " : "") + textPart;
                    }
                }
            });

            if (soundGenerationMethod === 'url') {
                if (audioSequenceForURL.length > 0) {
                    audioQueue = audioQueue.concat(audioSequenceForURL);
                    if (!isPlayingAudio) processAudioQueue();
                } else { console.warn("URL: No sounds generated for the announcement pattern."); }
            } else if (soundGenerationMethod === 'web_speech') {
                if (fullTextForTTS) {
                    console.log("Web Speech TTS: ", fullTextForTTS);
                    if ('speechSynthesis' in window) {
                        // Cancel any currently speaking utterances to prevent overlap if called rapidly
                        window.speechSynthesis.cancel();

                        const utterance = new SpeechSynthesisUtterance(fullTextForTTS);
                        utterance.lang = 'th-TH'; // Set desired language

                        // Find a Thai voice from the pre-loaded list
                        // Prioritize a voice that is marked as default for th-TH
                        let thaiVoice = ttsAvailableVoices.find(voice => voice.lang === 'th-TH' && voice.default);

                        if (!thaiVoice) {
                            // If no default th-TH voice, find any th-TH voice
                            thaiVoice = ttsAvailableVoices.find(voice => voice.lang === 'th-TH');
                        }

                        if (thaiVoice) {
                            utterance.voice = thaiVoice;
                            console.log("Using specific Thai voice:", thaiVoice.name, thaiVoice.lang, "Default:", thaiVoice.default);
                        } else {
                            console.warn("No specific Thai (th-TH) voice found in the available voices list. Relying on browser default for 'th-TH'.");
                            if (ttsAvailableVoices.length > 0) console.log("Available voices:", ttsAvailableVoices.map(v => ({name: v.name, lang: v.lang, default: v.default })));
                            else console.warn("No voices loaded at all. Speech synthesis might not work or 'onvoiceschanged' hasn't fired yet.");
                        }
                        window.speechSynthesis.speak(utterance);
                    } else {
                        console.error("Web Speech API (speechSynthesis) not supported by this browser.");
                    }
                } else { console.warn("Web Speech: No text generated for TTS."); }
            } else if (soundGenerationMethod === 'google_cloud_tts') {
                if (fullTextForTTS) {
                    console.log("Google Cloud TTS Request: ", fullTextForTTS);
                    google.script.run
                        .withSuccessHandler(handleGoogleCloudTTSResponse)
                        .withFailureHandler(handleGoogleCloudTTSError)
                        .generateGoogleCloudSpeech(fullTextForTTS);
                } else { console.warn("Google Cloud TTS: No text generated for TTS."); }
            }
        } // End of processQueueSoundInternal function
    } // End of playQueueSound function

    function handleGoogleCloudTTSResponse(result) {
        if (result.success && result.audioData) {
            playSoundFromBase64(result.audioData);
        } else {
            console.error("Google Cloud TTS Error:", result.error, result.details);
            // Optionally, display an error to the user or fallback to another sound method
        }
    }

    function handleGoogleCloudTTSError(error) {
        console.error("Error calling server-side Google Cloud TTS function:", error);
        // Optionally, display an error to the user
    }

    function playSoundFromBase64(base64AudioData) {
        if (!audioContext) {
            console.error("AudioContext not initialized for base64 playback.");
            initAudioContext(); 
            if (!audioContext) {
                console.error("Failed to initialize AudioContext after attempt for base64 playback.");
                return;
            }
        }
        if (audioContext.state === 'suspended') {
            audioContext.resume().catch(e => console.error("Resume AudioContext failed during base64 playback", e));
        }

        try {
            // Using <audio> element is simpler for direct playback of base64 MP3
            const audioSrc = 'data:audio/mp3;base64,' + base64AudioData;
            const audio = new Audio(audioSrc);
            audio.play().catch(e => console.error("Error playing base64 audio with <audio> element:", e));
            console.log("Attempting to play base64 audio via <audio> element.");

            audio.onended = () => {
                console.log("Base64 audio finished playing.");
            };
            audio.onerror = (e) => {
                console.error("Error event on <audio> element for base64:", e);
            };

        } catch (error) {
            console.error("Error processing or playing base64 audio:", error);
        }
    }

    async function playSoundFromUrl(url) {
        // Temporarily mute YouTube video if it's playing
        // const youtubeFrame = document.getElementById('youtubePlayer');
        // let videoWasPlaying = false;
        
        // if (youtubeFrame && youtubeFrame.style.display !== 'none') {
        //     videoWasPlaying = true;
        //     console.log("Temporarily pausing YouTube video for announcement");
        // }
        
        if (!audioContext) {
            console.error("AudioContext not initialized. Attempting to initialize...");
            initAudioContext();
            if (!audioContext) {
                console.error("Failed to initialize AudioContext. Cannot play sound.");
                isPlayingAudio = false; // Reset flag
                return; // Important: return to prevent further execution if context fails
            }
        }
        
        // Make sure AudioContext is running
        if (audioContext.state === 'suspended') {
            try {
                await audioContext.resume();
                console.log("AudioContext resumed before playing sound");
            } catch (e) {
                console.error("Failed to resume AudioContext:", e);
                // If resume fails, we probably can't play.
                // Consider how to handle this - maybe skip this sound.
                return; 
            }
        }
        
        try {
            console.log("Fetching sound from URL:", url);
            const response = await fetch(url, { cache: 'no-store' }); // Avoid caching issues
            if (!response.ok) {
                throw new Error("Failed to fetch sound " + url + ": " + response.statusText);
            }
            
            const arrayBuffer = await response.arrayBuffer();
            console.log("Sound data fetched, decoding audio...");
            
            // Check if audioContext is still valid before decoding
            if (!audioContext || audioContext.state !== 'running') {
                console.warn("AudioContext not running, cannot decode audio data for URL:", url);
                return;
            }
            
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            console.log("Audio decoded successfully, playing sound...");
            
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            
            // Create a gain node to ensure volume is at maximum (or desired level)
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 1.0; // Maximum volume
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            source.start(0);
            console.log("Sound started playing:", url);
            
            return new Promise(function(resolve) {
                source.onended = function() {
                    console.log("Sound finished playing:", url);
                    resolve();
                };
                // Add error handling for the source node itself if needed
                source.onerror = function(errEvent) { // This might not be standard for BufferSourceNode
                    console.error("Error on AudioBufferSourceNode for URL:", url, errEvent);
                    resolve(); // Resolve anyway to continue queue
                }
            });
        } catch (error) {
            console.error("Error playing sound from URL:", url, error);
            // Continue to next sound in queue even if one fails
            // Ensure the promise resolves or rejects to not stall the queue.
            return Promise.resolve(); // Resolve to continue
        }
    }

    async function processAudioQueue() {
        if (audioQueue.length === 0) {
            isPlayingAudio = false;
            console.log("URL Audio queue is empty, stopping playback");
            return;
        }
        
        isPlayingAudio = true;
        const soundItem = audioQueue.shift();
        
        let soundUrlToPlay;
        if (typeof soundItem === 'string') {
            soundUrlToPlay = soundItem;
        } else {
            console.warn("Unknown item in URL audio queue (expected string URL):", soundItem);
            // Skip this item and continue with next
            setTimeout(processAudioQueue, 100);
            return;
        }
        
        console.log("Playing sound from URL queue:", soundUrlToPlay);
        try {
            await playSoundFromUrl(soundUrlToPlay);
            // Slight delay before playing next sound to avoid abrupt transitions
            setTimeout(processAudioQueue, 200); // 200ms delay for better transitions
        } catch (error) {
            console.error("Error in processAudioQueue:", error);
            // Continue with next sound even if one fails
            setTimeout(processAudioQueue, 200);
        }
    }

    // Initialize DOM elements and set up event listeners when the document is ready
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM fully loaded");
        
        // Initialize DOM elements
        initDOMElements();
        
        // Set up event listeners
        setupEventListeners();
        
        // Auto-start after a short delay if no interaction
        setTimeout(function() {
            if (interactionOverlay && interactionOverlay.style.display !== 'none') {
                console.log("Auto-starting display after timeout");
                startDisplay();
            }
        }, 8000); // 5 seconds timeout
    });

    // Update the time display every second with clear formatting
    setInterval(function() {
        if (currentTimeEl) {
            const now = new Date();
            // Format time with clear hour:minute:second format
            currentTimeEl.textContent = now.toLocaleTimeString('th-TH', { 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit',
                hour12: false // Use 24-hour format
            });
        }
    }, 1000);

    // Final fallback - if the page has been loaded for 10 seconds and the display hasn't started yet,
    // initialize everything and start the display
    setTimeout(function() {
        console.log("Final fallback check");
        if (!refreshInterval) {
            console.log("Display hasn't started yet, forcing start");
            initDOMElements();
            startDisplay();
        }
    }, 10000);

</script>